Relatório Projeto Estruturas de Dados Avançados
Hugo Poças
26339
Introdução

Contexto e Motivação

A oportunidade de explorar e aprofundar o meu conhecimento em tópicos tão importantes e relevantes para esta àrea pode ser incrivelmente enriquecedora. Este projeto, centrado no estudo e aplicação de estruturas de dados avançadas, como listas ligadas e teoria dos grafos, é um excelente exemplo disso. Ao realizar este trabalho, tive a chance de melhorar a minha compreensão sobre estruturas de dados e as suas aplicações em contextos práticos, como a micromobilidade e as Smart Cities.
Este projeto desafiador proporcionou-me uma perspetiva mais profunda e uma apreciação pelo poder e versatilidade das estruturas de dados. Ao longo do processo, percebi o quão essenciais elas são para diversas aplicações, desde sistemas operacionais até redes sociais e sistemas de navegação. Consequentemente, estou ansioso para continuar a explorar e aplicar esse conhecimento em futuros projetos e iniciativas.

Objetivos do Projeto 
O projeto visa desenvolver uma solução de software que agilize a gestão (registo, partilha, utilização) de meios de mobilidade urbana num contexto de smart city. A implementação da solução considera o uso de estruturas de dados dinâmicas, armazenamento em ficheiros, modularização e documentação adequada. Além disso, o projeto busca aplicar as melhores práticas no desenvolvimento de software e estruturas de dados.

Estrutura do Relatório
Este relatório está organizado da seguinte forma: A Secção 2 apresenta uma revisão bibliográfica sobre micromobilidade, smart cities e estruturas de dados dinâmicas. A Secção 3 descreve o desenvolvimento do projeto em duas fases, detalhando as estruturas de dados utilizadas, funcionalidades implementadas e desafios enfrentados. A Secção 4 discute as ferramentas e metodologias utilizadas no projeto. A Secção 5 aborda os desafios e decisões tomadas durante o desenvolvimento. A Secção 6 discute possíveis alterações e melhorias no projeto. Por fim, a Seção 7 conclui o relatório, destacando as contribuições e limitações do projeto.
Desenvolvimento do Projeto

Fase 1: Definição de Estruturas e Implementação Inicial

Na primeira fase do projeto, o principal desafio foi definir as estruturas de dados para representar clientes, gestores, meios de mobilidade e transações, bem como estabelecer as relações entre elas. Decidiu-se criar uma estrutura separada para gestores em vez de adicionar um campo especial na estrutura dos clientes para indicar se um usuário é um gestor. Isso permitiu uma separação mais clara das responsabilidades e facilitou a implementação das funcionalidades específicas para cada tipo de usuário.

Inicialmente, as estruturas de dados foram implementadas usando arrays. No entanto, devido às limitações das arrays, como tamanho fixo e dificuldade em adicionar ou remover elementos, optou-se por converter todas as estruturas para listas ligadas. Listas ligadas oferecem maior flexibilidade e eficiência para manipular dados dinamicamente, tornando-se a escolha ideal para este projeto.

O projeto segue uma organização de ficheiros clara e modular, que é dividida em várias pastas, conforme a sua função:

├── Controller
│   ├── importexport.c
│   ├── main.c
│   └── verificacoes.c
├── Data
│   ├── Bin
│   └── Csv
│       ├── clients.csv
│       ├── gestores.csv
│       ├── matrix.csv
│       ├── transacoes.csv
│       └── transportes.csv
├── Headers
│   ├── clientes.h
│   ├── funcoes.h
│   ├── gestores.h
│   ├── grafo.h
│   ├── menugestor.h
│   ├── menuutilizador.h
│   ├── transacoes.h
│   ├── transportes.h
│   └── verificacoes.h
├── Model
│   ├── clientes.c
│   ├── gestores.c
│   ├── grafo.c
│   ├── transacoes.c
│   └── transportes.c
└── View
    ├── login.c
    ├── menu.c
    ├── menugestor.c
    └── menuutilizador.c

As principais pastas são:

Controller: Contém ficheiros relacionados à lógica de controlo do projeto, como importação e exportação de dados e verificações.
Data: Armazena ou lê os ficheiros de dados usados no projeto, incluindo ficheiros CSV e ficheiros binários.
Headers: Inclui os cabeçalhos e as declarações das funções utilizadas no projeto.
Model: Contém a implementação das estruturas de dados e funções relacionadas aos clientes, gestores, meios de mobilidade, transações e grafos.
View: Agrupa os ficheiros responsáveis pela interface do utilizador, como menus e login.

Fase 2: Implementação de Funcionalidades e Aperfeiçoamento das Estruturas
Com as estruturas de dados e a organização do projeto definidas, a próxima etapa envolveu a implementação das funcionalidades para a solução de software. A seguir, são apresentadas as principais funcionalidades implementadas e as suas características.

Registo e Autenticação de Utilizadores
O sistema permite o registo de novos clientes e gestores, armazenando os seus dados nas listas ligadas correspondentes. Os clientes são adicionados à lista ligada de uma maneira ordenada pelo NIF, garantindo assim a organização e a eficiência na procura de clientes específicos. Os clientes podem fornecer informações como nome, NIF, morada, saldo e localização, enquanto os gestores devem fornecer nome e senha. Os dados são validados para garantir a consistência e a integridade das informações armazenadas.

Após o registo, os utilizadores podem autenticar-se no sistema fornecendo o seu login e palavra-passe. A autenticação é realizada com base nos dados armazenados nas listas ligadas, e o sistema determina o tipo de utilizador (cliente ou gestor) com base na lista ligada em que os dados são encontrados.

 Gestão de Meios de Mobilidade
O sistema permite aos gestores adicionar, editar e remover meios de mobilidade. Os meios de mobilidade são armazenados numa lista ligada, e cada um possui informações como identificador, tipo, localização atual, preço por hora e estado (disponível, em uso ou em manutenção). Os gestores também podem visualizar uma lista de todos os meios de mobilidade disponíveis e filtrar com base em diferentes critérios, como localização e tipo.

Gestão de Transações
Os clientes podem realizar transações, como alugar e devolver meios de mobilidade. Ao realizar uma transação, o sistema verifica a disponibilidade do meio de mobilidade e o saldo do cliente. Se todas as condições forem satisfeitas, a transação é registada numa lista ligada de transações, e o estado do meio de mobilidade é atualizado.

Os gestores têm acesso a um histórico de todas as transações realizadas no sistema e podem filtrar as informações com base em diferentes critérios, como cliente, meio de mobilidade e data.

Navegação e Cálculo de Rotas
O projeto implementa um grafo para representar a rede de locais onde os meios de mobilidade podem ser encontrados. Os vértices do grafo representam os locais, e as arestas representam as ligações entre eles. .
Os clientes podem utilizar esta funcionalidade para encontrar a rota mais eficiente entre o seu local atual e o local onde desejam devolver o meio de mobilidade alugado.
Organização do Código e Princípios de Programação

O projeto segue o modelo Model-View-Controller (MVC) para organizar a estrutura de arquivos e separar as responsabilidades do sistema. Além disso, o princípio SOLID foi aplicado na implementação das funções, garantindo que cada função desempenhe apenas uma tarefa específica. Isso melhora a legibilidade e a manutenção do código.

As estruturas de dados para clientes, gestores, meios de mobilidade e transações estão implementadas nos arquivos "clientes.h", "gestores.h", "transportes.h" e "transacoes.h", respetivamente. Cada arquivo contém as definições das estruturas e funções relacionadas. O ficheiro "funcoes.h" inclui funções auxiliares e a lógica de negócio para interagir com as estruturas de dados e implementar as funcionalidades do sistema.

 Carregamento de Dados e Interação com Arquivos CSV

Para popular as estruturas de dados, foram criados arquivos CSV para clientes, gestores, meios de mobilidade, transações e grafo. Os arquivos utilizam delimitadores de tabulação, pois algumas informações poderiam conter vírgulas. O processo de carregamento dos dados envolve ler os arquivos CSV e preencher as estruturas de dados apropriadas. A função CarregarCSV coordena esse processo, chamando funções específicas para carregar cada tipo de arquivo.
Por exemplo, a função CarregarFicheiroClientes é responsável por carregar os dados dos clientes de um arquivo CSV. Ela abre o arquivo e, em seguida, chama a função LerClientesDeFicheiro para ler e processar as linhas do arquivo. A função LerClientesDeFicheiro extrai informações de cada linha usando a função sscanf, que lê e formata os dados de acordo com os especificadores de formato fornecidos. Após extrair os dados, a função InserirCliente é chamada para adicionar o cliente à lista ligada de clientes. O mesmo processo é seguido para carregar dados de gestores, meios de mobilidade e transações.
A leitura e o carregamento de dados a partir de arquivos CSV podem apresentar desafios, como a necessidade de lidar com delimitadores diferentes ou a possibilidade de encontrar dados corrompidos ou mal formatados. No entanto, o uso de funções auxiliares e a verificação dos dados lidos ajudam a mitigar esses desafios e garantir que os dados sejam carregados corretamente nas estruturas de dados.


Implementação do Grafo para Representar Barcelos

Para representar a cidade de Barcelos e as distâncias entre os diversos pontos de interesse, optou-se por utilizar um grafo, onde cada vértice corresponde a um local e as arestas representam a distância entre dois locais. Os pontos de interesse foram selecionados com base em informações disponíveis no TripAdvisor. Cada local foi atribuído um ID, que simula um geocódigo, e as distâncias entre os locais, apesar de fictícias, foram utilizadas para preencher a matriz de adjacência.

A estrutura do grafo foi armazenada num ficheiro CSV chamado 'matrix.csv'. Este ficheiro consiste numa matriz de adjacência, na qual cada linha e cada coluna correspondem a um local na cidade. Cada linha do ficheiro contém o ID do local, o nome do local, os IDs das localizações adjacentes e as distâncias correspondentes.

 Imagem : Excerto do ficheiro matrix.csv

Na imagem 1 podemos ver na primeira linha, o local com ID 1 (Torre do Cimo da Vila) tem três locais adjacentes: o local 2 (a uma distância de 350 metros), o local 3 (a 300 metros) e o local 4 (a 400 metros).

A função CarregarGrafo é utilizada para ler o ficheiro 'matrix.csv' e construir o grafo. A função percorre cada linha do ficheiro e, para cada linha, percorre cada coluna, adicionando uma aresta ao grafo para cada valor não zero encontrado.

A representação da cidade através de um grafo permitiu modelar as complexidades das rotas de uma forma compreensível e fácil de manipular. No entanto, também apresentou desafios, como a implementação de algoritmos de travessia de grafo, como a pesquisa em largura (Breadth-First Search), e a gestão eficiente do grafo, especialmente devido à necessidade de gerir uma quantidade considerável de memória e poder de processamento.

Algoritmos Utilizados

Algoritmo de Djikstra
No desenvolvimento deste projeto, foi crucial a implementação do algoritmo de Dijkstra para determinar o caminho mais curto entre dois pontos no contexto de uma cidade inteligente. Este algoritmo é fundamental para a eficiência da solução de software, pois permite otimizar a mobilidade urbana, encontrando os caminhos mais rápidos ou mais eficientes para os usuários.
 

Verificação inicial: O algoritmo começa verificando se a origem e o destino são iguais. Se forem, um caminho com um único vértice e distância 0 é retornado, pois não é necessário percorrer qualquer distância.

Inicialização: Se a origem e o destino não forem iguais, todos os vértices são inicializados e os vértices de origem e destino são procurados. Se algum dos vértices não for encontrado, o algoritmo retorna NULL, indicando que não é possível encontrar um caminho.

Processamento dos vértices: Se ambos os vértices forem encontrados, a distância do vértice de origem é definida como 0 e o vértice de origem é adicionado a uma fila de prioridade. O algoritmo então entra em um loop, processando cada vértice na fila de prioridade.

Atualização das distâncias: Para cada vértice processado, o algoritmo verifica todos os vértices adjacentes. Para cada vértice adjacente, calcula-se a nova distância como a soma da distância do vértice atual e a distância para o vértice adjacente. Se a nova distância for menor que a distância atual do vértice adjacente, a distância e o predecessor são atualizados. Se o vértice adjacente ainda não foi visitado, ele é adicionado à fila de prioridade.

Construção do caminho: Após todos os vértices terem sido processados, se não houver caminho para o destino (indicado por um predecessor de -1), o algoritmo retorna NULL. Caso contrário, o caminho é construído a partir do vértice de destino, seguindo os predecessores até chegar à origem. A distância total do caminho é então definida como a distância do vértice de destino.

Greedy Search
O outro algoritmo chave utilizado é o Greedy Search. Este é um algoritmo que tenta resolver o problema do caixeiro viajante, ou seja, encontrar o caminho mais curto que visita todos os vértices de um grafo e retorna ao vértice original.

 

A função GreedySearch implementa este algoritmo. Ela recebe como argumentos a lista de transportes, o grafo e o id do centro de recolha. O algoritmo começa no centro de recolha e, a cada passo, escolhe o transporte mais próximo que ainda não foi visitado. Este processo continua até que todos os transportes tenham sido visitados, e então o algoritmo retorna ao centro de recolha. O resultado final é o caminho mais curto que visita todos os transportes e retorna ao centro de recolha.

A implementação efetiva desses algoritmos apresentou alguns desafios. No entanto, com um bom entendimento das estruturas de dados e dos conceitos por trás destes algoritmos, foi possivel superar os desafios e implementar soluções eficientes.


Alterações nas Estruturas na Fase 2

Na fase 2 do projeto, foram feitas várias alterações nas estruturas de dados para acomodar novas funcionalidades e melhorar a eficiência do sistema. As principais alterações incluem a criação da estrutura Viagem para guardar o histórico dos clientes e a estrutura TipoTransporte para armazenar mais informações sobre o tipo de transporte.

Estrutura Viagem

A estrutura Viagem foi criada para armazenar o histórico de viagens dos clientes. Cada viagem inclui informações como o ID do transporte, a origem e o destino da viagem, o valor pago, o custo por quilômetro e a distância percorrida. Esta estrutura é ligada à estrutura Clientes através de um ponteiro historicoViagens, permitindo que cada cliente tenha um histórico de viagens associado.


Estrutura TipoTransporte

A estrutura TipoTransporte foi criada para armazenar mais informações sobre o tipo de transporte. Esta estrutura inclui informações como o ID do tipo de transporte, o nome, o peso e o preço por quilômetro. A estrutura Transporte foi atualizada para incluir um ponteiro para a estrutura TipoTransporte, permitindo que cada transporte tenha um tipo associado.

Estrutura Camião

Para simular a recolha de transportes no grafo, foi criada a estrutura Camiao. Esta estrutura contém informações sobre a capacidade máxima do camião em kg, a carga atual do camião em kg e a carga máxima que o camião pode transportar.


Funcionamento das Transações

O funcionamento das transações é um aspecto crucial do sistema, permitindo que os clientes aluguem e utilizem os transportes. O processo de transação é dividido em várias etapas:

Seleção do Transporte: O cliente escolhe um transporte para alugar.

Criação da Transação: Uma transação é criada com o ID do cliente e do transporte e é marcada como ativa.

Restrição de Viagens: Enquanto a viagem não terminar, o cliente não pode iniciar outra.

Término da Viagem: O cliente termina a viagem e indica onde a viagem terminou (ID do vértice).

Cálculo do Trajeto: Recorrendo à função de Dijkstra para o trajeto mais curto, o trajeto é calculado.

Atualização de Saldo e Bateria: Com os dados desse caminho (km percorridos), o saldo é retirado do cliente e a bateria é retirada do transporte. É importante notar que os clientes podem ficar com saldo negativo após uma viagem. No entanto, eles não poderão iniciar outra viagem até que façam um carregamento para aumentar o seu saldo.

Registro da Viagem: É gerada uma struct de viagem que é colocada no "histórico" do cliente, por meio de lista ligada.

Atualização da Localização: A localização do cliente e do transporte é alterada para o ID do vértice de destino.

Essas etapas garantem que o sistema funcione de maneira eficiente e que todas as transações sejam registradas corretamente.




Conclusão

Ao refletir sobre o trabalho realizado neste projeto, é evidente para mim o quanto cresci não apenas como programador, mas também como pensador crítico e solucionador de problemas. Este projeto, e a cadeira como um todo, mudou fundamentalmente a maneira como vejo o software e a programação.

Agora, quando interajo com qualquer tipo de software, encontro-me a pensar nas estruturas de dados subjacentes e nos algoritmos que tornam tudo possível. Esta nova perspectiva me deu uma apreciação mais profunda pela complexidade e beleza da programação.

Gostaria de expressar minha sincera gratidão ao professor pela sua orientação e disponibilidade ao longo deste projeto. O seu apoio e encorajamento foram inestimáveis e desempenharam um papel crucial no meu desenvolvimento.

Acredito firmemente que as competências e conhecimentos que adquiri nesta cadeira são de extrema importância e serão de grande utilidade na minha futura carreira. Estou ansioso para continuar a explorar este fascinante campo e a aplicar o que aprendi em futuros projetos.

Em conclusão, este projeto foi uma jornada desafiadora, mas extremamente gratificante. Embora não tenha conseguido alcançar tudo o que inicialmente desejava, estou orgulhoso do progresso que fiz e das soluções que consegui implementar. Este projeto serviu como uma valiosa experiência de aprendizado e estou ansioso para aplicar as lições aprendidas em futuros desafios de programação.